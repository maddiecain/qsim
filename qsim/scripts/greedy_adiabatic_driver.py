import numpy as np
import matplotlib.pyplot as plt
import networkx as nx
from qsim.codes import qubit, rydberg
from qsim import tools
from scipy.linalg import expm
import scipy.sparse as sparse
from scipy.sparse.linalg import expm_multiply
from qsim.graph_algorithms.graph import enumerate_independent_sets, independent_sets_qudit, \
    independence_polynomial, unit_disk_grid_graph
from qsim.evolution.hamiltonian import HamiltonianMIS, HamiltonianDriver
from scipy.sparse.linalg import eigsh

class HamiltonianWeightedDriver(object):
    def __init__(self, transition: tuple = (0, 1), energies: tuple = (1,), pauli='X', code=qubit,
                 graph: nx.Graph = None,
                 IS_subspace=False):
        """Default is that the first element in transition is the higher energy s."""
        self.transition = transition
        self.energies = energies
        assert pauli in ['X', 'Y', 'Z']
        self.pauli = pauli
        self.code = code
        self.graph = graph
        if self.pauli == 'X' and not self.code.logical_code:
            self._operator = np.zeros((self.code.d, self.code.d))
            self._operator[self.transition[1], self.transition[0]] = 1
            self._operator[self.transition[0], self.transition[1]] = 1
        elif self.pauli == 'Y' and not self.code.logical_code:
            self._operator = np.zeros((self.code.d, self.code.d))
            self._operator[self.transition[1], self.transition[0]] = 1j
            self._operator[self.transition[0], self.transition[1]] = -1j
        elif self.pauli == 'Z' and not self.code.logical_code:
            self._operator = np.zeros((self.code.d, self.code.d))
            self._operator[self.transition[0], self.transition[0]] = 1
            self._operator[self.transition[1], self.transition[1]] = -1
        # If a logical code, we should use the normal qubit operators because we assume the code is a qubit
        elif self.pauli == 'X' and self.code.logical_code:
            self._operator = self.code.X
        elif self.pauli == 'Y' and self.code.logical_code:
            self._operator = self.code.Y
        elif self.pauli == 'Z' and self.code.logical_code:
            self._operator = self.code.Z
        self.IS_subspace = IS_subspace

        if self.IS_subspace:
            # Generate sparse mixing Hamiltonian
            if code is not qubit:
                sets, num_sets = independent_sets_qudit(graph, self.code)
                if self.pauli == 'Z':
                    self._diagonal_hamiltonian = np.zeros((num_sets, 1))
                    for k in range(num_sets):
                        self._diagonal_hamiltonian[k, 0] = np.sum(sets[k, ...] == self.transition[0]) - np.sum(
                            sets[k, ...] == self.transition[1])

                    self._csr_hamiltonian = sparse.csr_matrix((self._diagonal_hamiltonian.T[0], (np.arange(num_sets),
                                                                                                 np.arange(num_sets))))

                    self._hamiltonian = self._csr_hamiltonian

                else:
                    # For each IS, look at spin flips generated by the laser
                    # Over-allocate space
                    rows = np.zeros(graph.number_of_nodes() * num_sets, dtype=int)
                    columns = np.zeros(graph.number_of_nodes() * num_sets, dtype=int)
                    entries = np.zeros(graph.number_of_nodes() * num_sets, dtype=int)
                    num_terms = 0
                    for i in range(num_sets):
                        for j in range(graph.number_of_nodes()):
                            if sets[i, j] == self.transition[0]:
                                # Flip spin at this location
                                # Get binary representation
                                temp = sets[i, ...].copy()
                                temp[j] = self.transition[1]
                                where_matched = (np.argwhere(np.sum(np.abs(sets - temp), axis=1) == 0).flatten())
                                if len(where_matched) > 0:
                                    # This is a valid spin flip by removing a node
                                    rows[num_terms] = where_matched[0]
                                    columns[num_terms] = i
                                    if self.pauli == 'X':
                                        entries[num_terms] = 1
                                    elif self.pauli == 'Y':
                                        # entries[num_terms] = -1j
                                        entries[num_terms] = 1j
                                    num_terms += 1
                    # Cut off the excess in the arrays
                    columns = columns[:2 * num_terms]
                    rows = rows[:2 * num_terms]
                    entries = entries[:2 * num_terms]
                    # Populate the second half of the entries according to self.pauli
                    if self.pauli == 'X':
                        columns[num_terms:2 * num_terms] = rows[:num_terms]
                        rows[num_terms:2 * num_terms] = columns[:num_terms]
                        entries[num_terms:2 * num_terms] = entries[:num_terms]
                    elif self.pauli == 'Y':
                        columns[num_terms:2 * num_terms] = rows[:num_terms]
                        rows[num_terms:2 * num_terms] = columns[:num_terms]
                        entries[num_terms:2 * num_terms] = -1 * entries[:num_terms]
                    # Now, construct the Hamiltonian
                    self._csr_hamiltonian = sparse.csr_matrix((entries, (rows, columns)), shape=(num_sets, num_sets))
                    self._hamiltonian = self._csr_hamiltonian
            else:
                # Use graph generator functions
                if self.pauli == 'Z':
                    sets = enumerate_independent_sets(graph)
                    num_sets = int(np.sum(independence_polynomial(graph)))
                    # Generate a list of integers corresponding to the independent sets in binary
                    # All ones
                    k = num_sets - 2
                    self.mis_size = 0
                    hamiltonian = np.zeros(num_sets, dtype=float)
                    hamiltonian[-1] = -1 * graph.number_of_nodes()
                    for i in sets:
                        hamiltonian[k] = len(i) - (graph.number_of_nodes() - len(i))
                        k -= 1

                    self._hamiltonian = sparse.csr_matrix(
                        (hamiltonian, (np.arange(num_sets), np.arange(num_sets))), shape=(num_sets, num_sets))

                else:
                    sets = enumerate_independent_sets(graph)
                    polynomial = independence_polynomial(graph)
                    num_sets = int(np.sum(polynomial))
                    # Generate a list of integers corresponding to the independent sets in binary
                    previous_size = 0
                    self.mis_size = 0
                    independent_sets_dict = {(): num_sets - 1}
                    rows = []
                    columns = []
                    entries = []
                    k = num_sets - 2
                    for i in sets:
                        current_size = len(i)
                        if current_size - previous_size > 1:
                            previous_size = current_size - 1
                            # Clear out the dictionary with terms we can't connect to
                            for key in list(independent_sets_dict):
                                if len(key) != previous_size:
                                    independent_sets_dict.pop(key)
                        independent_sets_dict[tuple(i)] = k
                        for (j, node) in enumerate(i):
                            i_removed = i.copy()
                            i_removed.pop(j)
                            index = independent_sets_dict[tuple(i_removed)]
                            # Index is the current independent set with a single node removed
                            rows.append(k)
                            columns.append(index)
                            rows.append(index)
                            columns.append(k)
                            if self.pauli == 'Y':
                                entries.append(-1j)
                                entries.append(1j)
                            else:
                                entries.append(self.graph.nodes[j]['weight'])
                                entries.append(self.graph.nodes[j]['weight'])
                        k -= 1
                    # Now, construct the Hamiltonian
                    self._csr_hamiltonian = sparse.csr_matrix((entries, (rows, columns)),
                                                              shape=(num_sets, num_sets))
                    self._hamiltonian = self._csr_hamiltonian
        else:
            self._hamiltonian = None
        self._left_acting_hamiltonian = None
        self._right_acting_hamiltonian = None

    @property
    def hamiltonian(self):
        if self._hamiltonian is None:
            assert not self.IS_subspace
            try:
                assert self.graph is not None
            except AssertionError:
                print('self.graph must be not None to generate the Hamiltonian property.')
            self._hamiltonian = sparse.csr_matrix(((self.code.d * self.code.n) ** self.graph.number_of_nodes(),
                                                   (self.code.d * self.code.n) ** self.graph.number_of_nodes()))
            for i in range(self.graph.number_of_nodes()):
                self._hamiltonian = self._hamiltonian + tools.tensor_product(
                    [sparse.identity((self.code.d * self.code.n) ** i),
                     self._operator,
                     sparse.identity((self.code.d * self.code.n) ** (self.graph.number_of_nodes() - i - 1))],
                    sparse=True)
        return self.energies[0] * self._hamiltonian

    @property
    def evolution_operator(self, vector_space='hilbert'):
        if vector_space != 'hilbert' and vector_space != 'liouville':
            raise Exception('Attribute vector_space must be hilbert or liouville')
        if vector_space == 'liouville':
            if self._left_acting_hamiltonian is None:
                self._left_acting_hamiltonian = sparse.kron(sparse.identity(self._hamiltonian.shape[0]),
                                                            self._hamiltonian)
                self._right_acting_hamiltonian = sparse.kron(self._hamiltonian.T,
                                                             sparse.identity(self._hamiltonian.shape[0]))

            return -1j * self.energies[0] * self._left_acting_hamiltonian + 1j * self.energies[0] * \
                   self._right_acting_hamiltonian
        else:
            return -1j * self.hamiltonian

    def left_multiply(self, state: np.ndarray):
        if not self.IS_subspace:
            temp = np.zeros_like(state)
            # For each logical qubit
            state_shape = state.shape
            for i in range(int(np.round(np.log(state.shape[0]) / np.log(self.code.d), 0))):
                if self.code.logical_code:
                    if self.pauli == 'X':
                        temp = temp + self.code.left_multiply(state, [i], ['X'])
                    elif self.pauli == 'Y':
                        temp = temp + self.code.left_multiply(state, [i], ['Y'])
                    elif self.pauli == 'Z':
                        temp = temp + self.code.left_multiply(state, [i], ['Z'])
                elif not self.code.logical_code:
                    ind = self.code.d ** i
                    out = np.zeros_like(state, dtype=np.complex128)
                    if state.is_ket:
                        state = state.reshape((-1, self.code.d, ind), order='F')
                        # Note index start from the right (sN,...,s3,s2,s1)
                        out = out.reshape((-1, self.code.d, ind), order='F')
                        if self.pauli == 'X':  # Sigma_X
                            # We want to exchange two indices
                            out[:, [self.transition[0], self.transition[1]], :] = \
                                state[:, [self.transition[1], self.transition[0]], :]
                        elif self.pauli == 'Y':  # Sigma_Y
                            out[:, [self.transition[0], self.transition[1]], :] = \
                                state[:, [self.transition[1], self.transition[0]], :]
                            out[:, self.transition[0], :] = -1j * out[:, self.transition[0], :]
                            out[:, self.transition[1], :] = 1j * out[:, self.transition[1], :]
                        elif self.pauli == 'Z':  # Sigma_Z
                            out[:, [self.transition[0], self.transition[1]], :] = \
                                state[:, [self.transition[0], self.transition[1]], :]
                            out[:, self.transition[1], :] = -1 * out[:, self.transition[1], :]
                        state = state.reshape(state_shape, order='F')
                        out = out.reshape(state_shape, order='F')
                    else:
                        out = out.reshape((-1, self.code.d, self.code.d ** (state.number_physical_qudits - 1),
                                           self.code.d, ind), order='F')
                        state = state.reshape((-1, self.code.d, self.code.d ** (state.number_physical_qudits - 1),
                                               self.code.d, ind), order='F')

                        if self.pauli == 'X':  # Sigma_X
                            out[:, [self.transition[0], self.transition[1]], :, :, :] = \
                                state[:, [self.transition[1], self.transition[0]], :, :, :]
                        elif self.pauli == 'Y':  # Sigma_Y
                            out[:, [self.transition[0], self.transition[1]], :, :, :] = \
                                state[:, [self.transition[1], self.transition[0]], :, :, :]
                            out[:, self.transition[0], :, :, :] = -1j * out[:, self.transition[0], :, :, :]
                            out[:, self.transition[1], :, :, :] = 1j * out[:, self.transition[1], :, :, :]
                        elif self.pauli == 'Z':  # Sigma_Z
                            out[:, [self.transition[0], self.transition[1]], :, :, :] = \
                                state[:, [self.transition[0], self.transition[1]], :, :, :]
                            out[:, self.transition[1], :, :, :] = -1 * out[:, self.transition[1], :, :, :]
                        state = state.reshape(state_shape, order='F')
                        out = out.reshape(state_shape, order='F')
                    temp = temp + out
            return self.energies[0] * temp
        else:
            # Handle dimensions
            if self.pauli == 'Z' and not self.code.logical_code:  # In this case, the Hamiltonian is diagonal
                return self.energies[0] * self._diagonal_hamiltonian * state
            else:
                return self.energies[0] * self._csr_hamiltonian @ state

    def right_multiply(self, state: np.ndarray):
        if state.shape[1] == 1:
            print('Warning: right multiply functionality currently applies the operator and daggers the state.')
            return self.left_multiply(state).conj().T
        if not self.IS_subspace:
            temp = np.zeros_like(state)
            # For each physical qubit
            state_shape = state.shape
            for i in range(int(np.round(np.log(state.shape[0]) / np.log(self.code.d) / self.code.n, 0))):
                if self.code.logical_code:
                    if self.pauli == 'X':
                        temp = temp + self.code.right_multiply(state, [i], ['X'])
                    elif self.pauli == 'Y':
                        temp = temp + self.code.right_multiply(state, [i], ['Y'])
                    elif self.pauli == 'Z':
                        temp = temp + self.code.right_multiply(state, [i], ['Z'])
                elif not self.code.logical_code:
                    ind = self.code.d ** i
                    out = np.zeros_like(state)
                    out = out.reshape(
                        (-1, self.code.d, self.code.d ** (state.number_physical_qudits - 1), self.code.d, ind),
                        order='F')
                    state = state.reshape(
                        (-1, self.code.d, self.code.d ** (state.number_physical_qudits - 1), self.code.d, ind),
                        order='F')
                    if self.pauli == 'X' and not self.code.logical_code:  # Sigma_X
                        out[:, :, :, [self.transition[0], self.transition[1]], :] = state[:, :, :, [self.transition[1],
                                                                                                    self.transition[0]],
                                                                                    :]
                    elif self.pauli == 'Y' and not self.code.logical_code:  # Sigma_Y
                        out[:, :, :, [self.transition[0], self.transition[1]], :] = state[:, :, :, [self.transition[1],
                                                                                                    self.transition[0]],
                                                                                    :]
                        out[:, :, :, self.transition[0], :] = -1j * out[:, :, :, self.transition[0], :]
                        out[:, :, :, self.transition[1], :] = 1j * out[:, :, :, self.transition[1], :]
                    elif self.pauli == 'Z' and not self.code.logical_code:  # Sigma_Z
                        out[:, :, :, [self.transition[0], self.transition[1]], :] = state[:, :, :, [self.transition[0],
                                                                                                    self.transition[1]],
                                                                                    :]
                        out[:, :, :, self.transition[1], :] = -1 * state[:, :, :, self.transition[1], :]
                        state = state.reshape(state_shape, order='F')
                    state = state.reshape(state_shape, order='F')
                    out = out.reshape(state_shape, order='F')
                    temp = temp + out
            return self.energies[0] * temp
        else:
            if self.pauli == 'Z' and not self.code.logical_code:  # In this case, the Hamiltonian is diagonal
                return state * self.hamiltonian.T
            else:
                return state @ self.hamiltonian.T.conj()

    def evolve(self, state: np.ndarray, time):
        r"""
        Use reshape to efficiently implement evolution under :math:`H_B=\\sum_i X_i`
        """
        if not self.IS_subspace:
            # We don't want to modify the original s
            out = state.copy()
            for i in range(int(np.round(np.log(state.shape[0]) / np.log(self.code.d), 0))):
                # Note that self._operator is not necessarily involutary
                if self.pauli == 'X':
                    out = self.code.rotation(out, [i], self.energies[0] * time, self._operator)
                elif self.pauli == 'Y':
                    out = self.code.rotation(out, [i], self.energies[0] * time, self._operator)
                elif self.pauli == 'Z':
                    out = self.code.rotation(out, [i], self.energies[0] * time, self._operator)
            return out
        else:
            if state.shape[1] == 1:
                # Handle dimensions
                if self.hamiltonian.shape[1] == 1:
                    return np.exp(-1j * time * self.hamiltonian) * state
                else:
                    return expm_multiply(-1j * time * self.hamiltonian, state)
            else:
                if self.hamiltonian.shape[1] == 1:
                    exp_hamiltonian = np.exp(-1j * time * self.hamiltonian)
                    return exp_hamiltonian * state * exp_hamiltonian.conj().T
                else:
                    exp_hamiltonian = expm(-1j * time * self.hamiltonian)
                    return exp_hamiltonian @ state @ exp_hamiltonian.conj().T


def degree_weighted(graph:nx.Graph):
    min_degree = np.inf
    for node in graph:
        if len(graph[node]) < min_degree:
            min_degree = len(graph[node])
    for node in graph:
        graph.nodes[node]['weight'] = 1/len(graph[node])*min_degree
    return graph

def degree_inverse_weighted(graph:nx.Graph):
    max_degree = 0
    for node in graph:
        if len(graph[node]) > max_degree:
            max_degree = len(graph[node])
    for node in graph:
        graph.nodes[node]['weight'] = len(graph[node])/max_degree
    return graph


def gap(graph):
    #grid = np.concatenate([np.ones(int(.8 * s ** 2)), np.zeros(s ** 2 - int(.8 * s ** 2))])
    #np.random.shuffle(grid)
    #grid = grid.reshape((s, s))
    cost = HamiltonianMIS(graph=graph, IS_subspace=True)
    driver_weighted = HamiltonianWeightedDriver(graph=degree_weighted(graph), IS_subspace=True)
    driver_inverse_weighted = HamiltonianWeightedDriver(graph=degree_inverse_weighted(graph), IS_subspace=True)
    driver_unweighted = HamiltonianDriver(graph=graph, IS_subspace=True)

    pulse = np.loadtxt('for_AWG_{}.000000.txt'.format(6))
    t_pulse_max = np.max(pulse[:, 0]) - 2 * 0.312
    print('Finished Hamiltonians')

    def schedule_exp_linear(t, T):
        if t < .312:
            driver_weighted.energies = (2 * np.pi * 2 * t / .312,)
            driver_inverse_weighted.energies = (2 * np.pi * 2 * t / .312,)
            driver_unweighted.energies = (2 * np.pi * 2 * t / .312,)
            cost.energies = (2 * np.pi * 15,)
        elif .312 <= t <= T - .312:
            driver_weighted.energies = (2 * np.pi * 2,)
            driver_inverse_weighted.energies = (2 * np.pi * 2,)
            driver_unweighted.energies = (2 * np.pi * 2,)
            cost.energies = (2 * np.pi * (-(11 + 15) / (T - 2 * .312) * (t - .312) + 15),)
        else:
            driver_weighted.energies = (2 * np.pi * 2 * (T - t) / .312,)
            driver_inverse_weighted.energies = (2 * np.pi * 2 * (T - t) / .312,)
            driver_unweighted.energies = (2 * np.pi * 2 * (T - t) / .312,)
            cost.energies = (-2 * np.pi * 11,)

    def gap(t, T):
        schedule_exp_linear(t, T)
        eigvals, eigvec = eigsh(driver_weighted.hamiltonian + cost.hamiltonian, k=4, which='SA')
        eigvals_uw, eigvec_uw = eigsh(driver_unweighted.hamiltonian + cost.hamiltonian, k=4, which='SA')
        eigvals_iw, eigvec_iw = eigsh(driver_inverse_weighted.hamiltonian + cost.hamiltonian, k=4, which='SA')
        print(t/t_pulse_max, (eigvals-eigvals[0])[1], (eigvals_uw-eigvals_uw[0])[1], (eigvals_iw-eigvals_iw[0])[1])
        return eigvals, eigvals_uw, eigvals_iw

    for t in np.linspace(.5, .8, 40):
        eigvals, eigvals_uw, eigvals_iw = gap(t*t_pulse_max, t_pulse_max)
        plt.scatter(np.ones_like(eigvals)*t, eigvals-eigvals[0], color='navy')
        plt.scatter(np.ones_like(eigvals_uw) * t, eigvals_uw - eigvals_uw[0], color='red')
        plt.scatter(np.ones_like(eigvals_iw) * t, eigvals_iw - eigvals_iw[0], color='goldenrod')
    plt.show()


i = 0
indices_7 = np.array([189, 623, 354, 40, 323, 173, 661, 345, 813, 35, 162, 965, 336,
                          667, 870, 1, 156, 901, 576, 346])
n = 7
index = indices_7[i]
degeneracy = np.loadtxt('configurations/mis_degeneracy_L%d.dat' % n)[index, 1].astype(int)
graph_mask = np.reshape(np.loadtxt('configurations/mis_degeneracy_L%d.dat' % n)[index, 3:],
                            (n, n), order='F')[::-1, ::-1].T.astype(bool)
graph = unit_disk_grid_graph(graph_mask, visualize=False)

gap(graph)



